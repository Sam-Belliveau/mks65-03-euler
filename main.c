#include <stdio.h>
#include <stdint.h>
#include <math.h>

// Allows me to change integer type 
// without rewriting program
typedef int_fast64_t integer;

integer euler_problem_1(integer);
integer euler_problem_2(integer);
integer euler_problem_3(integer);
integer euler_problem_4(integer);
integer euler_problem_5(integer, integer);
integer euler_problem_6(integer);

int main(void) 
{
    // some macros that make testing problems neater
    #define PROBLEM_HEADER(qnum) printf("\n\t- Question #" #qnum " -\n")
    #define TEST_FUNC(func, answer) printf(#func " \t-> %lld \t[" #answer "]\n", (long long)func)
    #define RUN_FUNC(func) printf(#func " \t-> %lld\n", (long long)func)

    PROBLEM_HEADER(1);
    TEST_FUNC(euler_problem_1(10), 23);
    RUN_FUNC(euler_problem_1(1000));

    PROBLEM_HEADER(2);
    TEST_FUNC(euler_problem_2(10), 10);
    TEST_FUNC(euler_problem_2(50), 44);
    RUN_FUNC(euler_problem_2(4000000));

    PROBLEM_HEADER(3);
    TEST_FUNC(euler_problem_3(13195), 29);
    TEST_FUNC(euler_problem_3(13 * 17 * 19), 19);
    TEST_FUNC(euler_problem_3(7 * 3 * 6), 7);
    RUN_FUNC(euler_problem_3(600851475143));
    
    PROBLEM_HEADER(4);
    TEST_FUNC(euler_problem_4(2), 9009);
    RUN_FUNC(euler_problem_4(3));

    PROBLEM_HEADER(5);
    TEST_FUNC(euler_problem_5(1, 3), 6);
    TEST_FUNC(euler_problem_5(1, 10), 2540);
    RUN_FUNC(euler_problem_5(1, 20));

    PROBLEM_HEADER(6);
    TEST_FUNC(euler_problem_6(10), 2640);
    RUN_FUNC(euler_problem_6(100));

    // Undefine all the print macros
    #undef PROBLEM_HEADER
    #undef TEST_FUNC
    #undef RUN_FUNC
}


/*****************/
/*** PROBLEM 1 ***/
/*****************/

/**
 * If we list all the natural numbers below 10 that are multiples 
 * of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
 * 
 * Find the sum of all the multiples of 3 or 5 below 1000.
 */
integer euler_problem_1(integer upper_bound) 
{
    integer sum;
    integer i;

    sum = 0;

    for (i = 0; i < upper_bound; ++i) 
    {
        if (!(i % 3) || !(i % 5)) 
        { sum += i; }
    }

    return sum;
}


/*****************/
/*** PROBLEM 2 ***/
/*****************/

/**
 * Each new term in the Fibonacci sequence is generated by 
 * adding the previous two terms. By starting with 1 and 2, 
 * the first 10 terms will be:
 * 
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * 
 * By considering the terms in the Fibonacci sequence whose 
 * values do not exceed four million, find the sum of the 
 * even-valued terms.
 */
integer euler_problem_2(integer limit) 
{
    integer x;
    integer y;
    integer z;
    integer sum;

    x = y = z = 1;
    sum = 0;

    while (x < limit) 
    {
        z = y;
        y = x;
        x = y + z;

        if(!(x & 1)) 
        { sum += x; }
    } 

    return sum;
}


/*****************/
/*** PROBLEM 3 ***/
/*****************/

/**
 * Find the largest prime factor of n
 */
integer euler_problem_3(integer n) 
{
    integer i;

    for (i = 2; i < n; i++) 
    {
        while (!(n % i)) { n /= i; }
        if (n == 1) { return i; }
    }

    return n;
}

/*****************/
/*** PROBLEM 4 ***/
/*****************/

integer get_digit(integer num, integer digit) 
{
    return (num / (integer) powl(10.0L, digit)) % 10;
}

integer palindromic(integer num) 
{
    integer size;
    integer i;
    
    size = floor(log10(num));

    for (i = 0; i <= (size >> 1); ++i) 
    {
        if (get_digit(num, i) != get_digit(num, size - i)) 
        { return 0; }
    }

    return 1;
}

/**
 * A palindromic number reads the same both ways. The largest palindrome 
 * made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
 * 
 * Find the largest palindrome made from the product of two 3-digit numbers.
 */
integer euler_problem_4(integer digits) 
{
    integer min;
    integer max;
    integer i, j;
    integer largest;
    integer prod;

    min = (integer) powl(10.0L, digits - 1);
    max = (integer) powl(10.0L, digits) - 1;
    largest = 0;

    for (i = max; i >= min; --i)
    for (j = max; j >= min; --j) 
    {
        prod = i * j;

        if (prod > largest && palindromic(prod))
        { largest = prod; }
    }
    
    return largest;
}


/*****************/
/*** PROBLEM 5 ***/
/*****************/

integer lcm(integer a, integer b) 
{
    integer o;

    o = a > b ? a : b;
    while((o % a) || (o % b)) { ++o; }

    return o;
}

/**
 * 2520 is the smallest number that can be divided by each 
 * of the numbers from 1 to 10 without any remainder.
 * 
 * What is the smallest positive number that is evenly 
 * divisible by all of the numbers from 1 to 20?
 */
integer euler_problem_5(integer min, integer max) 
{
    integer prod;
    integer i;

    prod = 1;

    for (i = min; i <= max; ++i) 
    { prod = lcm(i, prod); }

    return prod;
}


/*****************/
/*** PROBLEM 6 ***/
/*****************/

/**
 * Find the difference between the sum of the squares of the 
 * first one hundred natural numbers and the square of the sum.
 */
integer euler_problem_6(integer upper_bound) 
{
    integer i;
    integer sum_of_squares;
    integer square_of_sum;

    square_of_sum = (upper_bound) * (upper_bound + 1) / 2;
    square_of_sum *= square_of_sum;

    sum_of_squares = 0;
    
    for (i = 0; i <= upper_bound; ++i) 
    { sum_of_squares += i * i; }

    return square_of_sum - sum_of_squares;
}